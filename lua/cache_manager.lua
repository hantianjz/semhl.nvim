-- Cache Manager for semhl.nvim
-- Handles persistent storage of identifier â†’ color mappings

local M = {}

-- Get the cache file path
local function get_cache_path()
  local cache_dir = vim.fn.stdpath("cache") .. "/semhl"
  return cache_dir, cache_dir .. "/color_cache.lua"
end

-- Ensure cache directory exists
local function ensure_cache_dir()
  local cache_dir = get_cache_path()
  local stat = vim.loop.fs_stat(cache_dir)

  if not stat then
    local ok, err = pcall(vim.fn.mkdir, cache_dir, "p")
    if not ok then
      vim.notify("[semhl] Failed to create cache directory: " .. tostring(err), vim.log.levels.WARN)
      return false
    end
  end

  return true
end

-- Load cache from disk
function M.load_cache()
  local _, cache_file = get_cache_path()

  -- Check if cache file exists
  local stat = vim.loop.fs_stat(cache_file)
  if not stat then
    return { settings_hash = nil, colors = {} }
  end

  -- Try to load the cache file
  local ok, result = pcall(dofile, cache_file)
  if not ok then
    vim.notify("[semhl] Failed to load cache file, starting fresh: " .. tostring(result), vim.log.levels.WARN)
    return { settings_hash = nil, colors = {} }
  end

  -- Validate cache structure
  if type(result) ~= "table" or type(result.colors) ~= "table" then
    vim.notify("[semhl] Cache file corrupted, starting fresh", vim.log.levels.WARN)
    return { settings_hash = nil, colors = {} }
  end

  return result
end

-- Escape special characters in strings for serialization
local function escape_string(s)
  return s:gsub("\\", "\\\\"):gsub('"', '\\"'):gsub("\n", "\\n")
end

-- Serialize a Lua table to a string
local function serialize_table(tbl, indent)
  indent = indent or 0
  local lines = {}
  local prefix = string.rep("  ", indent)

  table.insert(lines, "{")

  -- Sort keys for deterministic output
  local keys = {}
  for k in pairs(tbl) do
    table.insert(keys, k)
  end
  table.sort(keys)

  for _, k in ipairs(keys) do
    local v = tbl[k]
    local key_str

    if type(k) == "string" then
      -- Escape quotes and special characters
      local escaped = escape_string(k)
      key_str = string.format('  %s["%s"]', prefix, escaped)
    else
      key_str = string.format("  %s[%s]", prefix, tostring(k))
    end

    if type(v) == "string" then
      local escaped = escape_string(v)
      table.insert(lines, string.format('%s = "%s",', key_str, escaped))
    elseif type(v) == "number" or type(v) == "boolean" then
      table.insert(lines, string.format("%s = %s,", key_str, tostring(v)))
    elseif type(v) == "table" then
      local nested = serialize_table(v, indent + 1)
      table.insert(lines, string.format("%s = %s,", key_str, nested))
    end
  end

  table.insert(lines, prefix .. "}")
  return table.concat(lines, "\n")
end

-- Move temporary file into place with cross-platform safety
local function finalize_cache_file(temp_file, cache_file)
  local ok, err = os.rename(temp_file, cache_file)
  if ok then
    return true
  end

  -- On Windows, os.rename fails if the destination exists. Try removing first.
  local existing = vim.loop.fs_stat(cache_file)
  if existing then
    local removed, remove_err = os.remove(cache_file)
    if not removed then
      return false,
        string.format("failed to rotate cache: %s (original rename error: %s)", tostring(remove_err), tostring(err))
    end

    ok, err = os.rename(temp_file, cache_file)
    if ok then
      return true
    end
  end

  -- Fall back to copying the file contents
  local temp_handle, temp_err = io.open(temp_file, "r")
  if not temp_handle then
    return false,
      string.format("failed to reopen temp cache: %s (original rename error: %s)", tostring(temp_err), tostring(err))
  end

  local content = temp_handle:read("*a")
  temp_handle:close()

  local cache_handle, cache_err = io.open(cache_file, "w")
  if not cache_handle then
    return false,
      string.format("failed to write cache using fallback: %s (original rename error: %s)", tostring(cache_err),
        tostring(err))
  end

  cache_handle:write(content)
  cache_handle:close()
  os.remove(temp_file)

  return true
end

-- Save cache to disk
function M.save_cache(cache)
  if not ensure_cache_dir() then
    return false
  end

  local _, cache_file = get_cache_path()
  local temp_file = cache_file .. ".tmp"

  -- Serialize cache to Lua table
  local content = "-- Auto-generated by semhl.nvim\nreturn " .. serialize_table(cache) .. "\n"

  -- Write to temporary file
  local file, err = io.open(temp_file, "w")
  if not file then
    vim.notify("[semhl] Failed to write cache: " .. tostring(err), vim.log.levels.WARN)
    return false
  end

  file:write(content)
  file:close()

  -- Atomic rename with cross-platform fallback
  local ok, finalize_err = finalize_cache_file(temp_file, cache_file)
  if not ok then
    vim.notify("[semhl] Failed to save cache: " .. tostring(finalize_err), vim.log.levels.WARN)
    return false
  end

  return true
end

-- Delete cache file from disk
function M.clear_cache_file()
  local _, cache_file = get_cache_path()

  local stat = vim.loop.fs_stat(cache_file)
  if stat then
    local ok, err = os.remove(cache_file)
    if not ok then
      vim.notify("[semhl] Failed to delete cache file: " .. tostring(err), vim.log.levels.WARN)
      return false
    end
  end

  return true
end

return M
